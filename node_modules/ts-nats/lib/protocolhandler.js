"use strict";
/*
 * Copyright 2018 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var nats_1 = require("./nats");
var muxsubscriptions_1 = require("./muxsubscriptions");
var error_1 = require("./error");
var events_1 = require("events");
var const_1 = require("./const");
var servers_1 = require("./servers");
var tcptransport_1 = require("./tcptransport");
var subscriptions_1 = require("./subscriptions");
var databuffer_1 = require("./databuffer");
var messagebuffer_1 = require("./messagebuffer");
var util_1 = require("./util");
var fs = require("fs");
var nkeys = require("ts-nkeys");
var PERMISSIONS_ERR = "permissions violation";
var STALE_CONNECTION_ERR = "stale connection";
// Protocol
var MSG = /^MSG\s+([^\s\r\n]+)\s+([^\s\r\n]+)\s+(([^\s\r\n]+)[^\S\r\n]+)?(\d+)\r\n/i, OK = /^\+OK\s*\r\n/i, ERR = /^-ERR\s+('.+')?\r\n/i, PING = /^PING\r\n/i, PONG = /^PONG\r\n/i, INFO = /^INFO\s+([^\r\n]+)\r\n/i, SUBRE = /^SUB\s+([^\r\n]+)\r\n/i, CREDS = /\s*(?:(?:[-]{3,}[^\n]*[-]{3,}\n)(.+)(?:\n\s*[-]{3,}[^\n]*[-]{3,}\n))/i, 
// Protocol
SUB = 'SUB', CONNECT = 'CONNECT', FLUSH_THRESHOLD = 65536;
var CRLF_BUF = Buffer.from('\r\n');
// Parser state
var ParserState;
(function (ParserState) {
    ParserState[ParserState["CLOSED"] = -1] = "CLOSED";
    ParserState[ParserState["AWAITING_CONTROL"] = 0] = "AWAITING_CONTROL";
    ParserState[ParserState["AWAITING_MSG_PAYLOAD"] = 1] = "AWAITING_MSG_PAYLOAD";
})(ParserState || (ParserState = {}));
var TlsRequirement;
(function (TlsRequirement) {
    TlsRequirement[TlsRequirement["OFF"] = -1] = "OFF";
    TlsRequirement[TlsRequirement["ANY"] = 0] = "ANY";
    TlsRequirement[TlsRequirement["ON"] = 1] = "ON";
})(TlsRequirement || (TlsRequirement = {}));
/**
 * @hidden
 */
var ProtocolHandler = /** @class */ (function (_super) {
    __extends(ProtocolHandler, _super);
    function ProtocolHandler(client, options) {
        var _this = _super.call(this) || this;
        _this.muxSubscriptions = new muxsubscriptions_1.MuxSubscriptions();
        _this.closed = false;
        _this.connected = false;
        _this.inbound = new databuffer_1.DataBuffer();
        _this.info = {};
        _this.infoReceived = false;
        _this.outbound = new databuffer_1.DataBuffer();
        _this.pongs = [];
        _this.pout = 0;
        _this.reconnecting = false;
        _this.reconnects = 0;
        _this.ssid = 1;
        _this.state = ParserState.AWAITING_CONTROL;
        _this.wasConnected = false;
        _this.draining = false;
        _this.noMorePublishing = false;
        events_1.EventEmitter.call(_this);
        _this.client = client;
        _this.options = options;
        _this.encoding = options.encoding || "utf8";
        _this.payload = options.payload || nats_1.Payload.STRING;
        _this.subscriptions = new subscriptions_1.Subscriptions();
        _this.subscriptions.on('subscribe', function (sub) {
            _this.client.emit('subscribe', sub);
        });
        _this.subscriptions.on('unsubscribe', function (unsub) {
            _this.client.emit('unsubscribe', unsub);
        });
        _this.servers = new servers_1.Servers(!_this.options.noRandomize, _this.options.servers || [], _this.options.url);
        _this.transport = new tcptransport_1.TCPTransport(_this.getTransportHandlers());
        return _this;
    }
    ProtocolHandler.connect = function (client, opts) {
        var _this = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var ph, lastError, fn;
            return __generator(this, function (_a) {
                ph = new ProtocolHandler(client, opts);
                lastError = null;
                fn = function (n) {
                    if (n <= 0) {
                        if (!ph.options.waitOnFirstConnect) {
                            reject(lastError);
                            return;
                        }
                    }
                    ph.connect()
                        .then(function () {
                        resolve(ph);
                    })
                        .catch(function (ex) {
                        // FIXME: cannot honor a delay
                        lastError = ex;
                        setTimeout(function () {
                            fn(n - 1);
                        }, ph.options.reconnectTimeWait || 0);
                    });
                };
                fn(ph.servers.length());
                return [2 /*return*/];
            });
        }); });
    };
    ProtocolHandler.prototype.flush = function (cb) {
        if (this.closed) {
            if (typeof cb === 'function') {
                cb(error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_CLOSED));
                return;
            }
            else {
                throw (error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_CLOSED));
            }
        }
        this.pongs.push(cb);
        this.sendCommand(this.buildProtocolMessage('PING'));
    };
    ProtocolHandler.prototype.close = function () {
        if (this.pingTimer) {
            clearTimeout(this.pingTimer);
            delete this.pingTimer;
        }
        this.closed = true;
        this.removeAllListeners();
        this.closeStream();
        this.ssid = -1;
        this.subscriptions.close();
        this.state = ParserState.CLOSED;
        this.pongs = [];
        this.outbound.reset();
    };
    ;
    ProtocolHandler.prototype.drain = function () {
        var _this = this;
        if (this.closed) {
            return Promise.reject(error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_CLOSED));
        }
        if (this.draining) {
            return Promise.reject(error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_DRAINING));
        }
        this.draining = true;
        var subs = this.subscriptions.all();
        var promises = [];
        subs.forEach(function (sub) {
            var p = _this.drainSubscription(sub.sid);
            promises.push(p);
        });
        return new Promise(function (resolve) {
            util_1.settle(promises)
                .then(function (a) {
                _this.noMorePublishing = true;
                process.nextTick(function () {
                    // send pending buffer
                    _this.flush(function () {
                        _this.close();
                        resolve(a);
                    });
                });
            })
                .catch(function () {
                // cannot happen
            });
        });
    };
    ProtocolHandler.prototype.publish = function (subject, data, reply) {
        if (reply === void 0) { reply = ""; }
        if (this.closed) {
            throw (error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_CLOSED));
        }
        if (this.noMorePublishing) {
            throw error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_DRAINING);
        }
        data = this.toBuffer(data);
        var len = data.length;
        var proto;
        if (reply) {
            proto = "PUB " + subject + " " + reply + " " + len;
        }
        else {
            proto = "PUB " + subject + " " + len;
        }
        this.sendCommand(this.buildProtocolMessage(proto, data));
    };
    ProtocolHandler.prototype.subscribe = function (s) {
        if (this.isClosed()) {
            throw (error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_CLOSED));
        }
        if (this.draining) {
            throw (error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_DRAINING));
        }
        var sub = this.subscriptions.add(s);
        if (sub.queue) {
            this.sendCommand(this.buildProtocolMessage("SUB " + sub.subject + " " + sub.queue + " " + sub.sid));
        }
        else {
            this.sendCommand(this.buildProtocolMessage("SUB " + sub.subject + " " + sub.sid));
        }
        if (s.max) {
            this.unsubscribe(this.ssid, s.max);
        }
        return new nats_1.Subscription(sub, this);
    };
    ProtocolHandler.prototype.drainSubscription = function (sid) {
        var _this = this;
        if (this.closed) {
            return Promise.reject(error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_CLOSED));
        }
        if (!sid) {
            return Promise.reject(error_1.NatsError.errorForCode(error_1.ErrorCode.SUB_CLOSED));
        }
        var s = this.subscriptions.get(sid);
        if (!s) {
            return Promise.reject(error_1.NatsError.errorForCode(error_1.ErrorCode.SUB_CLOSED));
        }
        if (s.draining) {
            return Promise.reject(error_1.NatsError.errorForCode(error_1.ErrorCode.SUB_DRAINING));
        }
        var sub = s;
        return new Promise(function (resolve) {
            sub.draining = true;
            _this.sendCommand(_this.buildProtocolMessage("UNSUB " + sid));
            _this.flush(function () {
                _this.subscriptions.cancel(sub);
                resolve({ sid: sub.sid, subject: sub.subject, queue: sub.queue });
            });
        });
    };
    ProtocolHandler.prototype.unsubscribe = function (sid, max) {
        if (!sid || this.closed) {
            return;
        }
        var s = this.subscriptions.get(sid);
        if (s) {
            if (max) {
                this.sendCommand(this.buildProtocolMessage("UNSUB " + sid + " " + max));
            }
            else {
                this.sendCommand(this.buildProtocolMessage("UNSUB " + sid));
            }
            s.max = max;
            if (s.max === undefined || s.received >= s.max) {
                this.subscriptions.cancel(s);
            }
        }
    };
    ProtocolHandler.prototype.request = function (r) {
        if (this.closed) {
            throw (error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_CLOSED));
        }
        if (this.draining) {
            throw (error_1.NatsError.errorForCode(error_1.ErrorCode.CONN_DRAINING));
        }
        this.initMux();
        this.muxSubscriptions.add(r);
        return new Request(r, this);
    };
    ProtocolHandler.prototype.numSubscriptions = function () {
        return this.subscriptions.length;
    };
    ProtocolHandler.prototype.isClosed = function () {
        return this.closed;
    };
    ProtocolHandler.prototype.cancelRequest = function (token, max) {
        if (!token || this.isClosed()) {
            return;
        }
        var r = this.muxSubscriptions.get(token);
        if (r) {
            r.max = max;
            if (r.max === undefined || r.received >= r.max) {
                this.muxSubscriptions.cancel(r);
            }
        }
    };
    ProtocolHandler.prototype.connect = function () {
        this.prepareConnection();
        if (this.currentServer.didConnect) {
            this.client.emit('reconnecting', this.url.href);
        }
        return this.transport.connect(this.url);
    };
    ProtocolHandler.prototype.flushPending = function () {
        if (!this.infoReceived) {
            return;
        }
        if (this.outbound.size()) {
            var d = this.outbound.drain();
            this.transport.write(d);
        }
    };
    ProtocolHandler.prototype.buildProtocolMessage = function (protocol, payload) {
        var protoLen = Buffer.byteLength(protocol);
        var cmd = protoLen + 2;
        var len = cmd;
        if (payload) {
            len += payload.byteLength + 2;
        }
        var buf = Buffer.allocUnsafe(len);
        buf.write(protocol);
        CRLF_BUF.copy(buf, protoLen);
        if (payload) {
            payload.copy(buf, cmd);
            CRLF_BUF.copy(buf, buf.byteLength - 2);
        }
        return buf;
    };
    ProtocolHandler.prototype.sendCommand = function (cmd) {
        // Buffer to cut down on system calls, increase throughput.
        // When receive gets faster, should make this Buffer based..
        var _this = this;
        if (this.closed) {
            return;
        }
        var buf;
        if (typeof cmd === 'string') {
            var len = Buffer.byteLength(cmd);
            buf = Buffer.allocUnsafe(len);
            buf.write(cmd, 0, len, "utf8");
        }
        else {
            buf = cmd;
        }
        if (buf.byteLength === 0) {
            return;
        }
        this.outbound.fill(buf);
        if (this.outbound.length() === 1) {
            setImmediate(function () {
                _this.flushPending();
            });
        }
        else if (this.outbound.size() > FLUSH_THRESHOLD) {
            this.flushPending();
        }
    };
    ProtocolHandler.prototype.getTransportHandlers = function () {
        var _this = this;
        var handlers = {};
        handlers.connect = function () {
            if (_this.pingTimer) {
                clearTimeout(_this.pingTimer);
                delete _this.pingTimer;
            }
            _this.connected = true;
            _this.scheduleHeartbeat();
        };
        handlers.close = function () {
            var wasConnected = _this.connected;
            _this.closeStream();
            //@ts-ignore - guaranteed to be set
            var mra = parseInt(_this.options.maxReconnectAttempts, 10);
            if (wasConnected) {
                _this.client.emit('disconnect', _this.currentServer.url.href);
            }
            if (_this.closed) {
                _this.client.close();
                _this.client.emit('close');
            }
            else if (_this.options.reconnect === false) {
                _this.client.close();
                _this.client.emit('close');
            }
            else if (mra > -1 && _this.reconnects >= mra) {
                _this.client.close();
                _this.client.emit('close');
            }
            else {
                _this.scheduleReconnect();
            }
        };
        handlers.error = function (exception) {
            // If we were connected just return, close event will process
            if (_this.wasConnected && _this.currentServer.didConnect) {
                return;
            }
            // if the current server did not connect at all, and we in
            // general have not connected to any server, remove it from
            // this list. Unless overridden
            if (!_this.wasConnected && !_this.currentServer.didConnect) {
                // We can override this behavior with waitOnFirstConnect, which will
                // treat it like a reconnect scenario.
                if (_this.options.waitOnFirstConnect) {
                    // Pretend to move us into a reconnect state.
                    _this.currentServer.didConnect = true;
                }
                else {
                    _this.servers.removeCurrentServer();
                }
            }
            // Only bubble up error if we never had connected
            // to the server and we only have one.
            if (!_this.wasConnected && _this.servers.length() === 0) {
                _this.client.emit('error', new error_1.NatsError(error_1.CONN_ERR_PREFIX + exception, error_1.ErrorCode.CONN_ERR, exception));
            }
            _this.closeStream();
        };
        handlers.data = function (data) {
            // If inbound exists, concat them together. We try to avoid this for split
            // messages, so this should only really happen for a split control line.
            // Long term answer is hand rolled parser and not regexp.
            _this.inbound.fill(data);
            // Process the inbound queue.
            _this.processInbound();
        };
        return handlers;
    };
    ProtocolHandler.prototype.prepareConnection = function () {
        // Commands may have been queued during reconnect. Discard everything except:
        // 1) ping requests with a pong callback
        // 2) publish requests
        //
        // Rationale: CONNECT and SUBs are written directly upon connecting, any PONG
        // response is no longer relevant, and any UNSUB will be accounted for when we
        // sync our SUBs. Without this, users of the client may miss state transitions
        // via callbacks, would have to track the client's internal connection state,
        // and may have to double buffer messages (which we are already doing) if they
        // wanted to ensure their messages reach the server.
        var _this = this;
        // copy outbound and reset it
        var buffers = this.outbound.reset();
        var pongs = [];
        if (buffers.length) {
            var pongIndex_1 = 0;
            // find all the pings with associated callback, and pubs
            buffers.forEach(function (buf) {
                var cmd = buf.toString('binary');
                if (PING.test(cmd) && _this.pongs !== null && pongIndex_1 < _this.pongs.length) {
                    var f = _this.pongs[pongIndex_1++];
                    if (f) {
                        _this.outbound.fill(buf);
                        pongs.push(f);
                    }
                }
                else if (cmd.length > 3 && cmd[0] === 'P' && cmd[1] === 'U' && cmd[2] === 'B') {
                    _this.outbound.fill(buf);
                }
            });
        }
        this.pongs = pongs;
        this.state = ParserState.AWAITING_CONTROL;
        // Clear info processing.
        this.info = {};
        this.infoReceived = false;
        // Select a server to connect to.
        this.selectServer();
    };
    ;
    ProtocolHandler.prototype.getInfo = function () {
        if (this.infoReceived) {
            return this.info;
        }
        return null;
    };
    /**
     * Strips all SUBS commands from pending during initial connection completed since
     * we send the subscriptions as a separate operation.
     *
     * @api private
     */
    ProtocolHandler.prototype.stripPendingSubs = function () {
        if (this.outbound.size() === 0) {
            return;
        }
        // FIXME: outbound doesn't peek so there's no packing
        var buffers = this.outbound.reset();
        for (var i = 0; i < buffers.length; i++) {
            var s = buffers[i].toString("binary");
            if (!SUBRE.test(s)) {
                // requeue the command
                this.sendCommand(buffers[i]);
            }
        }
    };
    /**
     * Sends existing subscriptions to new server after reconnect.
     *
     * @api private
     */
    ProtocolHandler.prototype.sendSubscriptions = function () {
        if (this.subscriptions.length === 0 || !this.transport.isConnected()) {
            return;
        }
        var cmds = [];
        this.subscriptions.all().forEach(function (s) {
            if (s.queue) {
                cmds.push(SUB + " " + s.subject + " " + s.queue + " " + s.sid + " " + const_1.CR_LF);
            }
            else {
                cmds.push(SUB + " " + s.subject + " " + s.sid + " " + const_1.CR_LF);
            }
        });
        if (cmds.length) {
            this.transport.write(cmds.join(''));
        }
    };
    /**
     * Process the inbound data queue.
     *
     * @api private
     */
    ProtocolHandler.prototype.processInbound = function () {
        var _this = this;
        // Hold any regex matches.
        var m;
        // For optional yield
        var start;
        if (!this.transport) {
            // if we are here, the stream was reaped and errors raised
            // if we continue.
            return;
        }
        // unpause if needed.
        this.transport.resume();
        if (this.options.yieldTime !== undefined) {
            start = Date.now();
        }
        while (!this.closed && this.inbound.size()) {
            switch (this.state) {
                case ParserState.AWAITING_CONTROL:
                    // Regex only works on strings, so convert once to be more efficient.
                    // Long term answer is a hand rolled parser, not regex.
                    var len = this.inbound.protoLen();
                    if (len === -1) {
                        return;
                    }
                    var bb = this.inbound.drain(len);
                    if (bb.byteLength === 0) {
                        return;
                    }
                    // specifying an encoding here like 'ascii' slows it down
                    var buf = bb.toString();
                    if ((m = MSG.exec(buf)) !== null) {
                        this.msgBuffer = new messagebuffer_1.MsgBuffer(m, this.payload, this.encoding);
                        this.state = ParserState.AWAITING_MSG_PAYLOAD;
                    }
                    else if ((m = OK.exec(buf)) !== null) {
                        // Ignore for now..
                    }
                    else if ((m = ERR.exec(buf)) !== null) {
                        this.processErr(m[1]);
                        return;
                    }
                    else if ((m = PONG.exec(buf)) !== null) {
                        this.pout = 0;
                        var cb = this.pongs && this.pongs.shift();
                        if (cb) {
                            try {
                                cb();
                            }
                            catch (err) {
                                console.error('error while processing pong', err);
                            }
                        } // FIXME: Should we check for exceptions?
                    }
                    else if ((m = PING.exec(buf)) !== null) {
                        this.sendCommand(this.buildProtocolMessage('PONG'));
                    }
                    else if ((m = INFO.exec(buf)) !== null) {
                        this.info = JSON.parse(m[1]);
                        // Check on TLS mismatch.
                        if (this.checkTLSMismatch()) {
                            return;
                        }
                        if (this.checkNoEchoMismatch()) {
                            return;
                        }
                        if (this.checkNonceSigner()) {
                            return;
                        }
                        // Always try to read the connect_urls from info
                        var change = this.servers.processServerUpdate(this.info);
                        if (change.deleted.length > 0 || change.added.length > 0) {
                            this.client.emit('serversChanged', change);
                        }
                        // Process first INFO
                        if (!this.infoReceived) {
                            // Switch over to TLS as needed.
                            // are we a tls socket?
                            var encrypted = this.transport.isEncrypted();
                            if (this.info.tls_required === true && !encrypted) {
                                this.transport.upgrade(this.options.tls, function () {
                                    _this.flushPending();
                                });
                            }
                            // Send the connect message and subscriptions immediately
                            var cs = JSON.stringify(new Connect(this.currentServer, this.options, this.info));
                            this.transport.write(CONNECT + " " + cs + const_1.CR_LF);
                            this.sendSubscriptions();
                            this.pongs.unshift(function () {
                                _this.connectCB();
                            });
                            this.transport.write(this.buildProtocolMessage('PING'));
                            // Mark as received
                            this.infoReceived = true;
                            this.stripPendingSubs();
                            this.flushPending();
                        }
                    }
                    else {
                        // FIXME, check line length for something weird.
                        // Nothing here yet, return
                        return;
                    }
                    break;
                case ParserState.AWAITING_MSG_PAYLOAD:
                    if (!this.msgBuffer) {
                        break;
                    }
                    // wait for more data to arrive
                    if (this.inbound.size() < this.msgBuffer.length) {
                        return;
                    }
                    // drain the number of bytes we need
                    var dd = this.inbound.drain(this.msgBuffer.length);
                    this.msgBuffer.fill(dd);
                    this.processMsg();
                    this.state = ParserState.AWAITING_CONTROL;
                    this.msgBuffer = null;
                    // Check to see if we have an option to yield for other events after yieldTime.
                    if (start !== undefined && this.options && this.options.yieldTime) {
                        if ((Date.now() - start) > this.options.yieldTime) {
                            this.transport.pause();
                            this.client.emit('yield');
                            setImmediate(function () {
                                _this.processInbound();
                            });
                            return;
                        }
                    }
                    break;
            }
        }
    };
    ProtocolHandler.prototype.clientTLSRequirement = function () {
        if (this.options.tls === undefined) {
            return TlsRequirement.ANY;
        }
        if (this.options.tls === false) {
            return TlsRequirement.OFF;
        }
        return TlsRequirement.ON;
    };
    /**
     * Check for TLS configuration mismatch.
     *
     * @api private
     */
    ProtocolHandler.prototype.checkTLSMismatch = function () {
        switch (this.clientTLSRequirement()) {
            case TlsRequirement.OFF:
                if (this.info.tls_required) {
                    this.client.emit('error', error_1.NatsError.errorForCode(error_1.ErrorCode.SECURE_CONN_REQ));
                    this.closeStream();
                    return true;
                }
                break;
            case TlsRequirement.ON:
                if (!this.info.tls_required) {
                    this.client.emit('error', error_1.NatsError.errorForCode(error_1.ErrorCode.NON_SECURE_CONN_REQ));
                    this.closeStream();
                    return true;
                }
                break;
            case TlsRequirement.ANY:
                // tls auto-upgrade
                break;
        }
        var cert = false;
        if (this.options.tls && typeof this.options.tls === 'object') {
            cert = this.options.tls.cert != null;
        }
        if (this.info.tls_verify && !cert) {
            this.client.emit('error', error_1.NatsError.errorForCode(error_1.ErrorCode.CLIENT_CERT_REQ));
            this.closeStream();
            return true;
        }
        return false;
    };
    /**
     * Check no echo
     * @api private
     */
    ProtocolHandler.prototype.checkNoEchoMismatch = function () {
        if ((this.info.proto === undefined || this.info.proto < 1) && this.options.noEcho) {
            this.client.emit('error', error_1.NatsError.errorForCode(error_1.ErrorCode.NO_ECHO_NOT_SUPPORTED));
            this.closeStream();
            return true;
        }
        return false;
    };
    ProtocolHandler.prototype.checkNonceSigner = function () {
        var _this = this;
        if (this.info.nonce === undefined) {
            return false;
        }
        if (this.options.userCreds) {
            try {
                // simple test that we got a creds file - exception is thrown
                // if the file is not a valid creds file
                this.getUserCreds(true);
                this.options.nonceSigner = function (nonce) {
                    return _this.signNonce(Buffer.from(nonce));
                };
                this.options.userJWT = function () {
                    return _this.loadJwt();
                };
            }
            catch (err) {
                this.client.emit('error', err);
                this.closeStream();
                return true;
            }
        }
        if (this.options.nonceSigner === undefined) {
            this.client.emit('error', error_1.NatsError.errorForCode(error_1.ErrorCode.SIGNATURE_REQUIRED));
            this.closeStream();
            return true;
        }
        if (this.options.nkey === undefined && this.options.userJWT === undefined) {
            this.client.emit('error', error_1.NatsError.errorForCode(error_1.ErrorCode.NKEY_OR_JWT_REQ));
            this.closeStream();
            return true;
        }
        return false;
    };
    // returns a regex array - first match is the jwt, second match is the nkey
    ProtocolHandler.prototype.getUserCreds = function (jwt) {
        if (jwt === void 0) { jwt = false; }
        if (this.options.userCreds) {
            var buf = fs.readFileSync(this.options.userCreds);
            if (buf) {
                var re = jwt ? CREDS : new RegExp(CREDS, 'g');
                var contents = buf.toString();
                // first match jwt
                var m = re.exec(contents);
                if (m === null) {
                    throw error_1.NatsError.errorForCode(error_1.ErrorCode.BAD_CREDS);
                }
                if (jwt) {
                    return m;
                }
                // second match the seed
                m = re.exec(contents);
                if (m === null) {
                    throw error_1.NatsError.errorForCode(error_1.ErrorCode.BAD_CREDS);
                }
                return m;
            }
        }
        throw error_1.NatsError.errorForCode(error_1.ErrorCode.BAD_CREDS);
    };
    // built-in handler for signing nonces based on user creds file
    ProtocolHandler.prototype.signNonce = function (nonce) {
        try {
            var m = this.getUserCreds();
            var sk = nkeys.fromSeed(Buffer.from(m[1]));
            return sk.sign(nonce);
        }
        catch (ex) {
            this.closeStream();
            this.client.emit('error', ex);
        }
    };
    // built-in handler for loading user jwt based on user creds file
    ProtocolHandler.prototype.loadJwt = function () {
        try {
            var m = this.getUserCreds(true);
            return m[1];
        }
        catch (ex) {
            this.closeStream();
            this.client.emit('error', ex);
        }
    };
    /**
     * Process a delivered message and deliver to appropriate subscriber.
     *
     * @api private
     */
    ProtocolHandler.prototype.processMsg = function () {
        if (this.subscriptions.length === 0 || !this.msgBuffer) {
            return;
        }
        var sub = this.subscriptions.get(this.msgBuffer.msg.sid);
        if (!sub) {
            return;
        }
        sub.received += 1;
        // cancel the timeout if we got the expected number of messages
        if (sub.timeout && (sub.max === undefined || sub.received >= sub.max)) {
            nats_1.Subscription.cancelTimeout(sub);
        }
        // if we got max number of messages, unsubscribe
        if (sub.max !== undefined && sub.received >= sub.max) {
            this.unsubscribe(sub.sid);
        }
        if (sub.callback) {
            try {
                if (this.msgBuffer.error) {
                    var empty = { sid: sub.sid, size: 0, reply: "", subject: sub.subject };
                    sub.callback(this.msgBuffer.error, empty);
                }
                else {
                    sub.callback(null, this.msgBuffer.msg);
                }
            }
            catch (error) {
                // client could have died
                console.log(error);
                this.client.emit('error', error);
            }
        }
    };
    ;
    ProtocolHandler.toError = function (s) {
        var t = s ? s.toLowerCase() : "";
        if (t.indexOf('permissions violation') !== -1) {
            return new error_1.NatsError(s, error_1.ErrorCode.PERMISSIONS_VIOLATION);
        }
        else if (t.indexOf('authorization violation') !== -1) {
            return new error_1.NatsError(s, error_1.ErrorCode.AUTHORIZATION_VIOLATION);
        }
        else {
            return new error_1.NatsError(s, error_1.ErrorCode.NATS_PROTOCOL_ERR);
        }
    };
    /**
     * ProcessErr processes any error messages from the server
     *
     * @api private
     */
    ProtocolHandler.prototype.processErr = function (s) {
        // current NATS clients, will raise an error and close on any errors
        // except stale connection and permission errors
        var err = ProtocolHandler.toError(s);
        switch (err.code) {
            case error_1.ErrorCode.AUTHORIZATION_VIOLATION:
                this.client.emit('error', err);
                // closeStream() triggers a reconnect if allowed
                this.closeStream();
                break;
            case error_1.ErrorCode.PERMISSIONS_VIOLATION:
                // just emit
                this.client.emit('permissionError', err);
                break;
            default:
                this.client.emit('error', err);
                // closeStream() triggers a reconnect if allowed
                this.closeStream();
        }
    };
    ;
    /**
     * Close down the stream and clear state.
     *
     * @api private
     */
    ProtocolHandler.prototype.closeStream = function () {
        this.transport.destroy();
        if (this.connected || this.closed) {
            this.pongs = [];
            this.pout = 0;
            this.connected = false;
            this.inbound.reset();
        }
    };
    ;
    /**
     * Setup a timer event to attempt reconnect.
     *
     * @api private
     */
    ProtocolHandler.prototype.scheduleReconnect = function () {
        var ph = this;
        // Just return if no more servers
        if (ph.servers.length() === 0) {
            return;
        }
        // Don't set reconnecting state if we are just trying
        // for the first time.
        if (ph.wasConnected) {
            ph.reconnecting = true;
        }
        // Only stall if we have connected before.
        var wait = 0;
        var s = ph.servers.next();
        if (s && s.didConnect && this.options.reconnectTimeWait !== undefined) {
            wait = this.options.reconnectTimeWait;
        }
        setTimeout(function () {
            ph.reconnect();
        }, wait);
    };
    ProtocolHandler.prototype.scheduleHeartbeat = function () {
        var _this = this;
        this.pingTimer = setTimeout(function () {
            _this.client.emit('pingtimer');
            if (_this.closed) {
                return;
            }
            // we could be waiting on the socket to connect
            if (_this.transport.isConnected()) {
                _this.client.emit('pingcount', _this.pout);
                _this.pout++;
                // @ts-ignore
                if (_this.pout > _this.options.maxPingOut) {
                    // processErr will scheduleReconnect
                    _this.processErr(STALE_CONNECTION_ERR);
                    // don't reschedule, new connection initiated
                    return;
                }
                else {
                    // send the ping
                    _this.sendCommand(_this.buildProtocolMessage('PING'));
                    if (_this.pongs) {
                        // no callback
                        _this.pongs.push(undefined);
                    }
                }
            }
            // reschedule
            _this.scheduleHeartbeat();
        }, this.options.pingInterval || const_1.DEFAULT_PING_INTERVAL, this);
    };
    /**
     * Reconnect to the server.
     *
     * @api private
     */
    ProtocolHandler.prototype.reconnect = function () {
        if (this.closed) {
            return;
        }
        this.reconnects += 1;
        this.connect().then(function () {
            // all good the pong handler deals with it
        }).catch(function () {
            // the stream handler deals with it
        });
    };
    /**
     * Properly select the next server.
     * We rotate the server list as we go,
     * we also pull auth from urls as needed, or
     * if they were set in options use that as override.
     *
     * @api private
     */
    ProtocolHandler.prototype.selectServer = function () {
        var server = this.servers.selectServer();
        if (server === undefined) {
            return;
        }
        // Place in client context.
        this.currentServer = server;
        this.url = server.url;
    };
    ProtocolHandler.prototype.toBuffer = function (data) {
        if (data === void 0) { data = undefined; }
        if (this.options.payload === nats_1.Payload.JSON) {
            // undefined is not a valid JSON-serializable value, but null is
            data = data === undefined ? null : data;
            try {
                data = JSON.stringify(data);
            }
            catch (e) {
                throw (error_1.NatsError.errorForCode(error_1.ErrorCode.BAD_JSON));
            }
        }
        else {
            data = data || const_1.EMPTY;
        }
        // if not a buffer, it is already serialized json or a string
        if (!Buffer.isBuffer(data)) {
            // must be utf8 - omitting encoding to prevent clever change
            data = Buffer.from(data);
        }
        return data;
    };
    ProtocolHandler.prototype.initMux = function () {
        var mux = this.subscriptions.getMux();
        if (!mux) {
            var inbox = this.muxSubscriptions.init();
            var sub = nats_1.defaultSub();
            // dot is already part of mux
            sub.subject = inbox + "*";
            sub.callback = this.muxSubscriptions.dispatcher();
            this.subscriptions.setMux(sub);
            this.subscribe(sub);
        }
    };
    /**
     * Callback for first flush/connect.
     *
     * @api private
     */
    ProtocolHandler.prototype.connectCB = function () {
        var event = this.reconnecting ? 'reconnect' : 'connect';
        this.reconnecting = false;
        this.reconnects = 0;
        this.wasConnected = true;
        if (this.currentServer) {
            this.currentServer.didConnect = true;
        }
        // copy the info
        var info = {};
        try {
            info = JSON.parse(JSON.stringify(this.info));
        }
        catch (err) {
            // ignore
        }
        this.client.emit(event, this.client, this.currentServer.url.href, info);
        this.flushPending();
    };
    return ProtocolHandler;
}(events_1.EventEmitter));
exports.ProtocolHandler = ProtocolHandler;
var Request = /** @class */ (function () {
    function Request(req, protocol) {
        this.token = req.token;
        this.protocol = protocol;
    }
    Request.prototype.cancel = function () {
        this.protocol.cancelRequest(this.token, 0);
    };
    return Request;
}());
exports.Request = Request;
var Connect = /** @class */ (function () {
    function Connect(server, opts, info) {
        this.lang = "typescript";
        this.version = nats_1.VERSION;
        this.verbose = false;
        this.pedantic = false;
        this.protocol = 1;
        opts = opts || {};
        if (opts.user) {
            this.user = opts.user;
            this.pass = opts.pass;
        }
        if (opts.token) {
            this.auth_token = opts.token;
        }
        var auth = server.getCredentials();
        if (auth) {
            if (auth.length !== 1) {
                if (this.user === undefined) {
                    this.user = auth[0];
                }
                if (this.pass === undefined) {
                    this.pass = auth[1];
                }
            }
            else if (this.auth_token === undefined) {
                this.auth_token = auth[0];
            }
        }
        if (opts.name) {
            this.name = opts.name;
        }
        if (opts.verbose !== undefined) {
            this.verbose = opts.verbose;
        }
        if (opts.pedantic !== undefined) {
            this.pedantic = opts.pedantic;
        }
        if (opts.noEcho) {
            this.echo = false;
        }
        if (info.nonce && opts.nonceSigner) {
            var sig = opts.nonceSigner(info.nonce);
            this.sig = sig.toString('base64');
        }
        if (opts.userJWT) {
            if (typeof opts.userJWT === 'function') {
                this.jwt = opts.userJWT();
            }
            else {
                this.jwt = opts.userJWT;
            }
        }
        if (opts.nkey) {
            this.nkey = opts.nkey;
        }
    }
    return Connect;
}());
exports.Connect = Connect;
//# sourceMappingURL=protocolhandler.js.map