"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2018 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var url = require("url");
var const_1 = require("./const");
var util_1 = require("./util");
/**
 * @hidden
 */
var Server = /** @class */ (function () {
    function Server(u, implicit) {
        if (implicit === void 0) { implicit = false; }
        // add scheme if not specified
        if (!/^.*:\/\/.*/.test(u)) {
            u = "nats://" + u;
        }
        this.url = url.parse(u);
        if (!this.url.port) {
            this.url.port = "" + const_1.DEFAULT_PORT;
        }
        this.didConnect = false;
        this.reconnects = 0;
        this.implicit = implicit;
    }
    Server.prototype.toString = function () {
        return this.url.href || "";
    };
    Server.prototype.getCredentials = function () {
        if ('auth' in this.url && !!this.url.auth) {
            return this.url.auth.split(':');
        }
        return undefined;
    };
    return Server;
}());
exports.Server = Server;
/**
 * @hidden
 */
var Servers = /** @class */ (function () {
    function Servers(randomize, urls, firstServer) {
        var _this = this;
        this.servers = [];
        if (urls) {
            urls.forEach(function (element) {
                _this.servers.push(new Server(element));
            });
            if (randomize) {
                this.servers = util_1.shuffle(this.servers);
            }
        }
        if (firstServer) {
            var index = urls.indexOf(firstServer);
            if (index === -1) {
                this.addServer(firstServer, false);
            }
            else {
                var fs = this.servers[index];
                this.servers.splice(index, 1);
                this.servers.unshift(fs);
            }
        }
        else {
            if (this.servers.length === 0) {
                this.addServer(const_1.DEFAULT_URI, false);
            }
        }
        this.currentServer = this.servers[0];
    }
    Servers.prototype.getCurrentServer = function () {
        return this.currentServer;
    };
    Servers.prototype.addServer = function (u, implicit) {
        if (implicit === void 0) { implicit = false; }
        this.servers.push(new Server(u, implicit));
    };
    Servers.prototype.selectServer = function () {
        var t = this.servers.shift();
        if (t) {
            this.servers.push(t);
            this.currentServer = t;
        }
        return t;
    };
    Servers.prototype.removeCurrentServer = function () {
        this.removeServer(this.currentServer);
    };
    Servers.prototype.removeServer = function (server) {
        if (server) {
            var index = this.servers.indexOf(server);
            this.servers.splice(index, 1);
        }
    };
    Servers.prototype.length = function () {
        return this.servers.length;
    };
    Servers.prototype.next = function () {
        return this.servers.length ? this.servers[0] : undefined;
    };
    Servers.prototype.getServers = function () {
        return this.servers;
    };
    Servers.prototype.processServerUpdate = function (info) {
        var _this = this;
        var added = [];
        var deleted = [];
        if (info.connect_urls && info.connect_urls.length > 0) {
            var discovered_1 = {};
            info.connect_urls.forEach(function (server) {
                // protocol in node includes the ':'
                var protocol = _this.currentServer.url.protocol;
                var u = protocol + "//" + server;
                discovered_1[u] = new Server(u, true);
            });
            // remove implicit servers that are no longer reported
            var toDelete_1 = [];
            this.servers.forEach(function (s, index) {
                var u = s.toString();
                if (s.implicit && _this.currentServer.url.href !== u && discovered_1[u] === undefined) {
                    // server was removed
                    toDelete_1.push(index);
                }
                // remove this entry from reported
                delete discovered_1[u];
            });
            // perform the deletion
            toDelete_1.reverse();
            toDelete_1.forEach(function (index) {
                var removed = _this.servers.splice(index, 1);
                deleted = deleted.concat(removed[0].url.toString());
            });
            // remaining servers are new
            for (var k in discovered_1) {
                if (discovered_1.hasOwnProperty(k)) {
                    this.servers.push(discovered_1[k]);
                    added.push(k);
                }
            }
        }
        return { added: added, deleted: deleted };
    };
    return Servers;
}());
exports.Servers = Servers;
//# sourceMappingURL=servers.js.map